/* Generated By:JavaCC: Do not edit this line. clike.java */
package traductor;
import java.io.*;
import lib.symbolTable.*;
import java.util.*;
import lib.symbolTable.exceptions.*;
import lib.errores.ErrorSemantico;
import lib.tools.codeGeneration.*;
import lib.tools.codeGeneration.PCodeInstruction.OpCode;

public class clike implements clikeConstants {

        protected static SymbolTable tablaSimbolos = new SymbolTable();
        protected static CodeBlock code = new CodeBlock();
        protected static boolean encontradoReturn = false;
        protected static boolean returnEnWhile = false;
        protected static boolean haHabidoError = false;
        protected static String outputName;

        public static void main(String[] args) {
                clike parser = null;

                try {
                        if(args.length == 0) {
                                parser = new clike(System.in);
                        }
                        else {
                                parser = new clike(new java.io.FileInputStream(args[0]));
                        }

                        if (args.length < 2) {
                                System.err.println("Error: Debe indicar el nombre del fichero de salida");
                                System.exit(1);
                        }

                        outputName = args[1];   // Nombre del fichero de salida

                        //Programa es el símbolo inicial de la gramática
                        parser.Programa();
                        //...
                        //System.out.println("***** Análisis terminado con éxito *****");
                }
                catch (java.io.FileNotFoundException e) {
                        System.err.println ("Fichero " + args[0] + " no encontrado.");
                }
                catch (TokenMgrError e) {
                        System.err.println("LEX_ERROR: " + e);
                        haHabidoError = true;
                }
                catch (ParseException e) {
                        System.err.println("PARSE_ERROR: " + e);
                        haHabidoError = true;
                }
                catch (Exception e) {
                        System.err.println("ERROR: " + e);
                        haHabidoError = true;

                }
        }


        public static void print_argument(Symbol.Types type){

                if (type == Symbol.Types.INT
                        ||
                        type == Symbol.Types.BOOL
                        )
                {
                        code.addInst(OpCode.WRT, 1);
                }
                else if (type == Symbol.Types.CHAR)
                {
                        code.addInst(OpCode.WRT, 0);
                }
                else if (type == Symbol.Types.STRING)
                {
                        // Los strings se imprimen conforme se reciben
                }
        }

//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
  static final public void Programa() throws ParseException {
        code.addInst(OpCode.ENP, "MAIN");

        Symbol temp_bin = new SymbolInt("compiler_temporal_int");
        try {
                tablaSimbolos.insertSymbol(temp_bin);
        }
        catch (AlreadyDefinedSymbolException e) {
                System.err.println("ERROR INTERNO, el identificador compiler_temporal_int ya est\u00e1 declarado");
                haHabidoError = true;
        }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tBOOL:
      case tCHAR:
      case tINT:
      case tVOID:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      declaracion();
    }
    jj_consume_token(0);
                code.addInst(OpCode.LVP);

                // Escribimos el código en un fichero
                if (!haHabidoError)
                {
                        System.out.println("Compilaci\u00f3n finalizada. Se ha generado el fichero " + outputName + ".pcode");
                        code.writeCodeToFile(outputName+".pcode");
                }
                else
                        System.err.println("No se ha generado el c\u00f3digo por haber errores en el programa");
  }

  static final public void declaracion() throws ParseException {
        List<Symbol> simbolos;
    if (jj_2_1(3)) {
      declaracion_variables();
      jj_consume_token(tPC);
    } else if (jj_2_2(2)) {
      declaracion_func_proc();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tBOOL:
      case tCHAR:
      case tINT:
      case tVOID:
        declaracion_main();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  static final public void declaracion_variables() throws ParseException {
        Symbol.Types type;
        List<Symbol> symbols;
    type = tipo();
    symbols = ids(type);
                try {
                        for (Symbol simbolo : symbols)
                                tablaSimbolos.insertSymbol(simbolo);
                }
                catch (AlreadyDefinedSymbolException e){
                        System.out.println(e);
                }
  }

  static final public ArrayList<Symbol> ids(Symbol.Types type) throws ParseException {
        ArrayList<Symbol> symbols = null;
        Symbol symbol;
    symbol = decl_1_variable(type);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tCOMMA:
      jj_consume_token(tCOMMA);
      symbols = ids(type);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
                if (symbols == null)
                        symbols = new ArrayList<Symbol>();

                symbols.add(symbol);
                {if (true) return symbols;}
    throw new Error("Missing return statement in function");
  }

  static final public Symbol decl_1_variable(Symbol.Types type) throws ParseException {
        Token id;
        Token size = null;
    id = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tACOR:
      jj_consume_token(tACOR);
      size = jj_consume_token(tCONST_INT);
      jj_consume_token(tCCOR);
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
                if (size != null)
                {
                        {if (true) return new SymbolArray(id.image, 0, Integer.parseInt(size.image)-1, type);}
                }
                else
                        {if (true) return Symbol.createNormalSymbol(id.image, type);}
    throw new Error("Missing return statement in function");
  }

  static final public void declaracion_main() throws ParseException {
        Symbol.Types tipo;
        Token token;
        ArrayList<Symbol> parametros = null;
        Symbol simbolo;
    tipo = tipo();
    token = jj_consume_token(tMAIN);
    jj_consume_token(tAP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tBOOL:
    case tCHAR:
    case tINT:
    case tVOID:
      parametros = declaracion_parametros();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    jj_consume_token(tCP);
                if (parametros == null)
                {
                        parametros = new ArrayList<Symbol>();
                }

                if (tipo == Symbol.Types.VOID)
                {
                        simbolo = new SymbolProcedure(token.image, parametros);
                }
                else
                {
                        simbolo = new SymbolFunction(token.image, parametros, tipo);
                }

                try{
                        tablaSimbolos.insertSymbol(simbolo);
                }
                catch (AlreadyDefinedSymbolException e){
                        System.out.println(e);
                }

                for (Symbol simb : parametros)
                {
                        try{
                                tablaSimbolos.insertSymbol(simb);
                        }
                        catch (AlreadyDefinedSymbolException e) {
                                System.out.println(e+", simbolo "+simb);
                        }
                }

                code.addLabel("MAIN");
    bloque_codigo_con_variables();
                tablaSimbolos.removeBlock();
  }

  static final public void declaracion_func_proc() throws ParseException {
        Symbol.Types tipo;
        Token token;
        ArrayList<Symbol> parametros = null;
        Symbol simbolo;
    tipo = tipo();
    token = jj_consume_token(tID);
                if (tipo == Symbol.Types.VOID)
                {
                        simbolo = new SymbolProcedure(token.image);
                }
                else
                {
                        simbolo = new SymbolFunction(token.image, tipo);
                        encontradoReturn = false;
                }

                try{
                        tablaSimbolos.insertSymbol(simbolo);
                }
                catch (AlreadyDefinedSymbolException e){
                        System.out.println(e);
                }

                tablaSimbolos.insertBlock(token.image);
                code.addLabel(token.image.toUpperCase().replace("_", ""));
    jj_consume_token(tAP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tBOOL:
    case tCHAR:
    case tINT:
    case tVOID:
      parametros = declaracion_parametros();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
    jj_consume_token(tCP);
                if (parametros == null)
                {
                        parametros = new ArrayList<Symbol>();
                }

                Symbol funcSimb = simbolo;
                if (funcSimb instanceof SymbolFunction)
                {
                        SymbolFunction func = (SymbolFunction) funcSimb;
                        func.setParameters(parametros);
                }
                else if (funcSimb instanceof SymbolProcedure)
                {
                        SymbolProcedure func = (SymbolProcedure) funcSimb;
                        func.setParameters(parametros);
                }
    bloque_codigo_con_variables();
                tablaSimbolos.removeBlock();

                if (tipo != Symbol.Types.VOID && !encontradoReturn)
                {
                        if (returnEnWhile)
                        {
                                ErrorSemantico.deteccion("Error, los returns en un while no garantizan que la funci\u00f3n " + simbolo.name + " termine con return");
                                haHabidoError = true;
                        }
                        else
                        {
                                ErrorSemantico.deteccion("Error, la funci\u00f3n " + simbolo.name + " puede no terminar con return");
                                haHabidoError = true;
                        }
                }

                if (tipo == Symbol.Types.VOID)
                {
                        code.addInst(OpCode.CSF);
                }
  }

  static final public ArrayList<Symbol> declaracion_parametros() throws ParseException {
        Symbol symbol;
        ArrayList<Symbol> parametros = new ArrayList<Symbol>();
    symbol = declaracion_parametro();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tCOMMA:
      jj_consume_token(tCOMMA);
      parametros = declaracion_parametros();
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
                parametros.add(0, symbol);

                try{
                        tablaSimbolos.insertSymbol(symbol);
                }
                catch (AlreadyDefinedSymbolException e) {
                        System.out.println(e+", simbolo "+symbol);
                }

                if (symbol.type == Symbol.Types.ARRAY && symbol.parClass == Symbol.ParameterClass.VAL) //Si es un array, nos apilan la dirección del array (el primer elemento)
                {
                        SymbolArray array = (SymbolArray) symbol;
                        int arraySize = array.maxInd-array.minInd+1;
                        int nivelRelativo = tablaSimbolos.level - symbol.nivel; //Para saber el desplazamiento restamos el level donde apuntamos menos el nivel al que queremos ir

                        for (int i = arraySize-1; i >= 0; i--)
                        {
                                code.addInst(OpCode.SRF, nivelRelativo, (int)array.dir+i);              // Nos apilan el valor de la variable
                                code.addInst(OpCode.ASGI);
                        }
                }
                else
                {
                        int nivelRelativo = tablaSimbolos.level - symbol.nivel; //Para saber el desplazamiento restamos el level donde apuntamos menos el nivel al que queremos ir
                        code.addInst(OpCode.SRF, nivelRelativo, (int)symbol.dir);                       // Nos apilan el valor de la variable
                        code.addInst(OpCode.ASGI);
                }

                {if (true) return parametros;}
    throw new Error("Missing return statement in function");
  }

  static final public Symbol declaracion_parametro() throws ParseException {
        Symbol.Types type;
        Symbol symbol;
        Token ref = null;
    type = tipo();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tREFER:
      ref = jj_consume_token(tREFER);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    symbol = decl_1_variable(type);
                if (ref != null)
                {
                        symbol.parClass = Symbol.ParameterClass.REF;
                        {if (true) return symbol;}
                }
                else
                {
                        symbol.parClass = Symbol.ParameterClass.VAL;
                        {if (true) return symbol;}
                }
    throw new Error("Missing return statement in function");
  }

  static final public void instruccion() throws ParseException {
        Symbol.Types type;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tREAD:
      inst_leer();
      jj_consume_token(tPC);
      break;
    case tREADLN:
      inst_leer_linea();
      jj_consume_token(tPC);
      break;
    case tPRINT:
      inst_escribir();
      jj_consume_token(tPC);
      break;
    case tPRINTLN:
      inst_escribir_linea();
      jj_consume_token(tPC);
      break;
    default:
      jj_la1[8] = jj_gen;
      if (jj_2_3(2)) {
        type = inst_invoc_proc();
                if (type != Symbol.Types.VOID)
                        code.addInst(OpCode.POP);       // Si solo se ha llamado a la funcion, elimina su resultado

        jj_consume_token(tPC);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tID:
          inst_asignacion();
          jj_consume_token(tPC);
          break;
        case tIF:
          inst_seleccion();
          break;
        case tWHILE:
          inst_iteracion();
          break;
        case tRETURN:
          inst_return();
          jj_consume_token(tPC);
          break;
        default:
          jj_la1[9] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  static final public void inst_leer() throws ParseException {
        Symbol simb;
        Symbol.Types symbolType = null;
    jj_consume_token(tREAD);
    jj_consume_token(tAP);
    symbolType = expresion(true);
                if (symbolType == Symbol.Types.INT || symbolType == Symbol.Types.BOOL)
                        code.addInst(OpCode.RD, 1);
                else if (symbolType == Symbol.Types.CHAR)
                        code.addInst(OpCode.RD, 0);
                else
                {
                        ErrorSemantico.deteccion("En read(), la variable no es de tipo entero, char o Boolean", null);
                        haHabidoError = true;
                }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMMA:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_2;
      }
      jj_consume_token(tCOMMA);
      symbolType = expresion(true);
                        if (symbolType == Symbol.Types.INT || symbolType == Symbol.Types.BOOL)
                                code.addInst(OpCode.RD, 1);
                        else if (symbolType == Symbol.Types.CHAR)
                                code.addInst(OpCode.RD, 0);
                        else
                        {
                                ErrorSemantico.deteccion("En read(), la variable no es de tipo entero, char o Boolean", null);
                                haHabidoError = true;
                        }
    }
    jj_consume_token(tCP);
  }

  static final public void inst_leer_linea() throws ParseException {
        Token token;
        Symbol simb = null;
        Symbol.Types symbolType = null;
    jj_consume_token(tREADLN);
    jj_consume_token(tAP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tAP:
    case tMENOS:
    case tNOT:
    case tFALSE:
    case tTRUE:
    case tINT2CHAR:
    case tCHAR2INT:
    case tCONST_STRING:
    case tCONST_INT:
    case tCONST_CHAR:
    case tID:
      symbolType = expresion(true);
                if (symbolType == Symbol.Types.INT || symbolType == Symbol.Types.BOOL)
                        code.addInst(OpCode.RD, 1);
                else if (symbolType == Symbol.Types.CHAR)
                        code.addInst(OpCode.RD, 0);
                else
                {
                        ErrorSemantico.deteccion("En read(), la variable no es de tipo entero, char o Boolean", null);
                        haHabidoError = true;
                }
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMMA:
        ;
        break;
      default:
        jj_la1[12] = jj_gen;
        break label_3;
      }
      jj_consume_token(tCOMMA);
      symbolType = expresion(true);
                        if (symbolType == Symbol.Types.INT || symbolType == Symbol.Types.BOOL)
                                code.addInst(OpCode.RD, 1);
                        else if (symbolType == Symbol.Types.CHAR)
                                code.addInst(OpCode.RD, 0);
                        else
                        {
                                ErrorSemantico.deteccion("En read(), la variable no es de tipo entero, char o Boolean", null);
                                haHabidoError = true;
                        }
    }
    jj_consume_token(tCP);
                Symbol simb_bin = tablaSimbolos.getSymbol("compiler_temporal_int");

                String label = CGUtils.newLabel();
                code.addLabel("READLNLOOP" + label);

                int nivelRelativo = tablaSimbolos.level - simb_bin.nivel;
                code.addInst(OpCode.SRF, nivelRelativo, (int)simb_bin.dir);
                code.addInst(OpCode.RD, 0);

                code.addInst(OpCode.SRF, nivelRelativo, (int)simb_bin.dir);
                code.addInst(OpCode.DRF);

                code.addInst(OpCode.STC, '\n');
                code.addInst(OpCode.NEQ);
                code.addInst(OpCode.JMT, "READLNLOOP" + label);
                // Añadimos bucle hasta detectar salto de línea

  }

  static final public void inst_escribir() throws ParseException {
        ArrayList<Symbol.Types> types;
    jj_consume_token(tPRINT);
    jj_consume_token(tAP);
    argumentos_escribir();
    jj_consume_token(tCP);
  }

  static final public void inst_escribir_linea() throws ParseException {
    jj_consume_token(tPRINTLN);
    jj_consume_token(tAP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tAP:
    case tMENOS:
    case tNOT:
    case tFALSE:
    case tTRUE:
    case tINT2CHAR:
    case tCHAR2INT:
    case tCONST_STRING:
    case tCONST_INT:
    case tCONST_CHAR:
    case tID:
      argumentos_escribir();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    jj_consume_token(tCP);
                code.addInst(OpCode.STC, '\n');
                code.addInst(OpCode.WRT, 0);
  }

  static final public void argumentos_escribir() throws ParseException {
        Symbol.Types type;
    type = expresion(false);
                if (type != Symbol.Types.ARRAY){
                        print_argument(type);
                }
                else{
                        ErrorSemantico.deteccion("Se est\u00e1 intentando imprimir un vector completo");
                        haHabidoError = true;
                }
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_4;
      }
      jj_consume_token(tCOMMA);
      type = expresion(false);
                                              print_argument(type);
    }

  }

  static final public ArrayList<Symbol.Types> argumentos(ArrayList<Symbol> arguments, String name, Integer line) throws ParseException {
        Symbol.Types type;
        ArrayList<Symbol.Types> types = new ArrayList<Symbol.Types>();
        ArrayList<Symbol> arguments_internal = new ArrayList<Symbol>(arguments);
    type = expresion(arguments_internal.get(0).parClass == Symbol.ParameterClass.REF);
                types.add(type);

                if (arguments_internal.size() > 0)
                        arguments_internal.remove(0);
                else
                {
                        ErrorSemantico.deteccion("Hay m\u00e1s argumentos de la cuenta en la llamada a funci\u00f3n "+name+", linea: "+line);
                        haHabidoError = true;
                }
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tCOMMA:
        ;
        break;
      default:
        jj_la1[15] = jj_gen;
        break label_5;
      }
      jj_consume_token(tCOMMA);
      type = expresion(arguments_internal.get(0).parClass == Symbol.ParameterClass.REF);
                        types.add(type);

                        if (arguments_internal.size() > 0)
                                arguments_internal.remove(0);
                        else
                        {
                                ErrorSemantico.deteccion("Hay m\u00e1s argumentos de la cuenta en la llamada a funci\u00f3n "+name+", linea: "+line);
                                haHabidoError = true;
                        }
    }
                if (arguments_internal.size() > 0)
                {
                        ErrorSemantico.deteccion("Hay menos argumentos de la cuenta en la llamada a funci\u00f3n "+name+", linea: "+line);
                        haHabidoError = true;
                }
                {if (true) return types;}
    throw new Error("Missing return statement in function");
  }

  static final public void inst_asignacion() throws ParseException {
        Symbol.Types symbolAss, symbolExp;
    symbolAss = asignable();
    jj_consume_token(tASSIGN);
    symbolExp = expresion(false);
                if (symbolAss != symbolExp)
                {
                        ErrorSemantico.deteccion("En asignaci\u00f3n, la expresi\u00f3n de tipo " + symbolExp + " no coincide con el tipo de la variable: "+symbolAss, token);
                        haHabidoError = true;
                }

                code.addInst(OpCode.ASG);
  }

  static final public Symbol.Types asignable() throws ParseException {
        Symbol.Types index = null;
        Token token;
        SymbolArray array = null;
    token = jj_consume_token(tID);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tACOR:
      jj_consume_token(tACOR);
      index = expresion(false);
      jj_consume_token(tCCOR);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
                if (index == null)
                {
                        try {
                                Symbol simbolo = tablaSimbolos.getSymbol(token.image);

                                int nivelRelativo =  tablaSimbolos.level - simbolo.nivel;
                                code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);      // Dirección de la variable

                                if (simbolo.parClass == Symbol.ParameterClass.REF)
                                        code.addInst(OpCode.DRF);

                                {if (true) return simbolo.type;}
                        }
                        catch(SymbolNotFoundException e)
                        {
                                ErrorSemantico.deteccion("El s\u00edmbolo " + token.image + " no existe, l\u00ednea " + token.beginLine);
                                haHabidoError = true;
                        }

                        {if (true) return null;}
                }
                else // Nuestro simbolo forma parte de un vector
                {
                        if (index != Symbol.Types.INT)
                        {
                                ErrorSemantico.deteccion("En asignaci\u00f3n, el \u00edndice del vector " + token.image + " no es de tipo entero", token);
                                haHabidoError = true;
                        }

                        try {
                                array = (SymbolArray) tablaSimbolos.getSymbol(token.image);
                        }
                        catch(SymbolNotFoundException e)
                        {
                                ErrorSemantico.deteccion("El simbolo "+token.image+" no existe, l\u00ednea "+token.beginLine);
                        }

                        // Cálculo de dirección del indexado, base+index

                        int nivelRelativo = tablaSimbolos.level - array.nivel;
                        code.addInst(OpCode.SRF, nivelRelativo, (int)array.dir);

                        if (array.parClass == Symbol.ParameterClass.REF)
                                code.addInst(OpCode.DRF);

                        code.addInst(OpCode.PLUS);

                        {if (true) return array.baseType;}
                }
    throw new Error("Missing return statement in function");
  }

  static final public void inst_seleccion() throws ParseException {
        String label = "ETIQUETANOVALIDA";      ;
        String labelEnd = "ENDCONDITIONAL" + CGUtils.newLabel();
        Boolean oldReturn = encontradoReturn;   // Para controlar si hay un return dentro del if
        Boolean buscarReturn = !encontradoReturn;
        Boolean encontradoReturn_en_if = false;
        Boolean encontradoReturn_en_if_else = false;
        Boolean encontradoReturn_en_else = false;
        Symbol.Types condicion;
    jj_consume_token(tIF);
    jj_consume_token(tAP);
    condicion = expresion(false);
    jj_consume_token(tCP);
                if (condicion == Symbol.Types.BOOL){
                        label = "ENDIF" + CGUtils.newLabel();
                        code.addInst(OpCode.JMF, label);
                }
                else{
                        ErrorSemantico.deteccion("En la selecci\u00f3n, la condici\u00f3n usada no es de tipo booleano, es de tipo " + condicion);
                        haHabidoError = true;
                }
    bloque_codigo();
                code.addInst(OpCode.JMP, labelEnd);
                code.addLabel(label);

                if (buscarReturn && encontradoReturn) // Si ha aparecido un return
                {
                        encontradoReturn_en_if = true;
                        encontradoReturn = false;
                }
                else            // Si no se ha encontrado un return 
                {
                        encontradoReturn_en_if = false;
                }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tELSE:
      if (jj_2_4(2)) {
        encontradoReturn_en_if_else = bloque_else_ifs(labelEnd, buscarReturn, true);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tELSE:
          jj_consume_token(tELSE);
          bloque_codigo();
                        if (buscarReturn && encontradoReturn) // Si ha aparecido un return
                        {
                                encontradoReturn_en_else = true;
                                encontradoReturn = false;
                        }
                        else            // Si no se ha encontrado un return 
                        {
                                encontradoReturn_en_else = false;
                        }
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
                code.addLabel(labelEnd);
                encontradoReturn = !buscarReturn || (encontradoReturn_en_if && (encontradoReturn_en_else || encontradoReturn_en_if_else));
  }

  static final public Boolean bloque_else_ifs(String labelEnd, Boolean buscarReturn, Boolean buscarElse) throws ParseException {
        String label;

        Boolean oldReturn = encontradoReturn;   // Para controlar si hay un return dentro del if
        Boolean encontradoReturn_en_if = false;
        Boolean encontradoReturn_en_else = false;
    jj_consume_token(tELSE);
    jj_consume_token(tIF);
    jj_consume_token(tAP);
    expresion(false);
    jj_consume_token(tCP);
                label = "ENDELSEIF" + CGUtils.newLabel();
                code.addInst(OpCode.JMF, label);
    bloque_codigo();
                code.addInst(OpCode.JMP, labelEnd);
                code.addLabel(label);

                if (buscarReturn && encontradoReturn) // Si ha aparecido un return
                {
                        encontradoReturn_en_if = true;
                        encontradoReturn = false;
                }
                else            // Si no se ha encontrado un return 
                {
                        encontradoReturn_en_if = false;
                }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tELSE:
      if (jj_2_5(2)) {
        bloque_else_ifs(labelEnd, buscarReturn, false);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tELSE:
          jj_consume_token(tELSE);
          bloque_codigo();
                        if (buscarReturn && encontradoReturn) // Si ha aparecido un return
                        {
                                encontradoReturn_en_else = true;
                                encontradoReturn = false;
                        }
                        else            // Si no se ha encontrado un return 
                        {
                                encontradoReturn_en_else = false;
                        }
          break;
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
                code.addLabel(labelEnd);

                if (!buscarElse)
                        encontradoReturn_en_else = true;

                {if (true) return !buscarReturn || (encontradoReturn_en_else && encontradoReturn_en_if);}
    throw new Error("Missing return statement in function");
  }

  static final public void inst_iteracion() throws ParseException {
        String labelInit = "INITWHILE" + CGUtils.newLabel();
        String labelEnd = "ENDWHILE" + CGUtils.newLabel();
        code.addLabel(labelInit);
        Boolean habiaReturn = encontradoReturn;
        Symbol.Types condicion;
    jj_consume_token(tWHILE);
    jj_consume_token(tAP);
    condicion = expresion(false);
                code.addInst(OpCode.JMF, labelEnd);
    jj_consume_token(tCP);
    bloque_codigo();
                if (condicion == Symbol.Types.BOOL){
                        code.addInst(OpCode.JMP, labelInit);
                        code.addLabel(labelEnd);

                        encontradoReturn = habiaReturn; // Dentro de un while, los returns pueden no suceder
                        returnEnWhile = true;
                }
                else{
                        ErrorSemantico.deteccion("En la iteraci\u00f3n, la condici\u00f3n usada no es de tipo booleano, es de tipo " + condicion);
                        haHabidoError = true;
                }
  }

  static final public void bloque_codigo() throws ParseException {
    jj_consume_token(tIBLOQUE);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tWHILE:
      case tIF:
      case tPRINT:
      case tPRINTLN:
      case tREAD:
      case tREADLN:
      case tRETURN:
      case tID:
        ;
        break;
      default:
        jj_la1[21] = jj_gen;
        break label_6;
      }
      instruccion();
    }
    jj_consume_token(tFBLOQUE);
  }

  static final public void bloque_codigo_con_variables() throws ParseException {
    jj_consume_token(tIBLOQUE);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tBOOL:
      case tCHAR:
      case tINT:
      case tVOID:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_7;
      }
      declaracion_variables();
      jj_consume_token(tPC);
    }
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tWHILE:
      case tIF:
      case tPRINT:
      case tPRINTLN:
      case tREAD:
      case tREADLN:
      case tRETURN:
      case tID:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_8;
      }
      instruccion();
    }
    jj_consume_token(tFBLOQUE);
  }

  static final public Symbol.Types inst_return() throws ParseException {
        Symbol.Types type;
        Token token = null;
        Symbol symb = null;
    token = jj_consume_token(tRETURN);
    type = expresion(false);
                String funcName = tablaSimbolos.getBlockName();

                try {
                        symb = tablaSimbolos.getSymbol(funcName);
                }
                catch(SymbolNotFoundException e)
                {
                        ErrorSemantico.deteccion("El return de la l\u00ednea "+token.beginLine+" no pertenece a ninguna funci\u00f3n");
                }

                SymbolFunction simbolFunc = null;

                if (symb == null)
                {
                        ErrorSemantico.deteccion("El bloque actual no es una funci\u00f3n o procedimiento", token);
                        haHabidoError = true;
                }
                else {
                        if (symb instanceof SymbolFunction)
                                simbolFunc = (SymbolFunction) symb;
                        else
                        {
                                ErrorSemantico.deteccion("El bloque actual no admite returns", token);
                                haHabidoError = true;
                        }
                }


                if (simbolFunc != null && type != simbolFunc.returnType)
                {
                        ErrorSemantico.deteccion("En return, el tipo de la expresi\u00f3n no coincide con el tipo de retorno de la funci\u00f3n", token);
                        haHabidoError = true;
                }

                encontradoReturn = true;

                code.addInst(OpCode.CSF);
                {if (true) return type;}
    throw new Error("Missing return statement in function");
  }

  static final public Symbol.Types inst_invoc_proc() throws ParseException {
        Token token;
        Symbol.Types tipo = null;
        Boolean error = false;
        ArrayList<Symbol> parameters = new ArrayList<Symbol>();
        String name = "";
    token = jj_consume_token(tID);
                try{
                        Symbol SimboloDeFuncion = tablaSimbolos.getSymbol(token.image);

                        if (SimboloDeFuncion.type == Symbol.Types.PROCEDURE)
                        {
                                SymbolProcedure procedimiento = (SymbolProcedure) SimboloDeFuncion;
                                tipo = Symbol.Types.VOID;

                                parameters = procedimiento.parList;
                                name = procedimiento.name;
                        }
                        else if (SimboloDeFuncion.type == Symbol.Types.FUNCTION)
                        {
                                SymbolFunction funcion = (SymbolFunction) SimboloDeFuncion;
                                tipo = funcion.returnType;

                                parameters = funcion.parList;
                                name = funcion.name;
                        }
                        else
                        {
                                ErrorSemantico.deteccion("El identificador " + token.image + " no es una funci\u00f3n ni un procedimiento", token);
                                haHabidoError = true;
                        }
                }
                catch (SymbolNotFoundException e) {
                        error = true;
                        System.out.println(e+", linea "+token.beginLine+", columna "+token.beginColumn);
                        haHabidoError = true;
                }
    jj_consume_token(tAP);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tAP:
    case tMENOS:
    case tNOT:
    case tFALSE:
    case tTRUE:
    case tINT2CHAR:
    case tCHAR2INT:
    case tCONST_STRING:
    case tCONST_INT:
    case tCONST_CHAR:
    case tID:
      argumentos(parameters, name, token.beginLine);
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    jj_consume_token(tCP);
                if (!error){
                        code.addOSFInst(tablaSimbolos.getTopDir(), tablaSimbolos.level, name.toUpperCase().replace("_", ""));
                        {if (true) return tipo;}
                }
    throw new Error("Missing return statement in function");
  }

  static final public String operador_not() throws ParseException {
        Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tNOT:
      token = jj_consume_token(tNOT);
                           {if (true) return "!";}
      break;
    case tMENOS:
      token = jj_consume_token(tMENOS);
                                                               {if (true) return "-";}
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Symbol.Types expresion(Boolean sendRef) throws ParseException {
        Symbol.Types factor1Type, factor2Type = null;
        String token = null;
        String label = "ENDANDOR" + CGUtils.newLabel();
    factor1Type = relacion(sendRef);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tOR:
      case tAND:
        ;
        break;
      default:
        jj_la1[26] = jj_gen;
        break label_9;
      }
      token = and_or();
                        if (token == "||")
                        {
                                code.addInst(OpCode.DUP);
                                code.addInst(OpCode.JMT, label);
                                code.addInst(OpCode.POP);
                        }
                        else
                        {
                                code.addInst(OpCode.DUP);
                                code.addInst(OpCode.JMF, label);
                                code.addInst(OpCode.POP);
                        }
      factor2Type = relacion(sendRef);
                        if (factor1Type != Symbol.Types.BOOL || factor2Type!= Symbol.Types.BOOL)
                        {
                                ErrorSemantico.deteccion("En operaci\u00f3n l\u00f3gica, los operandos deben ser de tipo Boolean ("+
                                                                                factor1Type+", "+factor2Type+")");
                                haHabidoError = true;
                        }
    }
                if (factor2Type != null)
                {
                        code.addLabel(label);
                        {if (true) return Symbol.Types.BOOL;}
                }
                else
                {
                        {if (true) return factor1Type;}
                }
    throw new Error("Missing return statement in function");
  }

  static final public String and_or() throws ParseException {
        Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tOR:
      token = jj_consume_token(tOR);
                          {if (true) return "||";}
      break;
    case tAND:
      token = jj_consume_token(tAND);
                           {if (true) return "&&";}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Symbol.Types relacion(Boolean sendRef) throws ParseException {
        Symbol.Types factor1Type, factor2Type = null;
        String token = null;
    factor1Type = expresion_simple(sendRef);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMEN:
    case tMAY:
    case tMENI:
    case tMAYI:
    case tDIF:
    case tIG:
      token = operador_relacional();
      factor2Type = expresion_simple(sendRef);
                        if (factor1Type != factor2Type)
                        {
                                ErrorSemantico.deteccion("En relacion,los operandos deben ser del mismo tipo ("+
                                                                                factor1Type+", "+factor2Type+")");
                                haHabidoError = true;
                        }

                        if (token == "==")
                                code.addInst(OpCode.EQ);
                        else if (token == "<")
                                code.addInst(OpCode.LT);
                        else if (token == ">")
                                code.addInst(OpCode.GT);
                        else if (token == "<=")
                                code.addInst(OpCode.LTE);
                        else if (token == ">=")
                                code.addInst(OpCode.GTE);
                        else if (token == "!=")
                                code.addInst(OpCode.NEQ);
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
                if (factor2Type != null)
                {
                        {if (true) return Symbol.Types.BOOL;}
                }
                else
                {
                        {if (true) return factor1Type;}
                }
    throw new Error("Missing return statement in function");
  }

  static final public String operador_relacional() throws ParseException {
        Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tIG:
      token = jj_consume_token(tIG);
                          {if (true) return "==";}
      break;
    case tMEN:
      token = jj_consume_token(tMEN);
                           {if (true) return "<";}
      break;
    case tMAY:
      token = jj_consume_token(tMAY);
                           {if (true) return ">";}
      break;
    case tMENI:
      token = jj_consume_token(tMENI);
                            {if (true) return "<=";}
      break;
    case tMAYI:
      token = jj_consume_token(tMAYI);
                            {if (true) return ">=";}
      break;
    case tDIF:
      token = jj_consume_token(tDIF);
                           {if (true) return "!=";}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Symbol.Types expresion_simple(Boolean sendRef) throws ParseException {
        Symbol.Types factor1Type, factor2Type = null;
        String token = null;
    factor1Type = termino(sendRef);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tMAS:
      case tMENOS:
        ;
        break;
      default:
        jj_la1[30] = jj_gen;
        break label_10;
      }
      token = op_MAS_MENOS();
      factor2Type = termino(sendRef);
                        if (factor1Type != factor2Type)
                        {
                                ErrorSemantico.deteccion("En expresi\u00f3n simple, los operandos deben ser del mismo tipo");
                                haHabidoError = true;
                        }

                        if (token == "+")
                                code.addInst(OpCode.PLUS);
                        else
                                code.addInst(OpCode.SBT);
    }
                if (factor2Type != null)
                {
                        {if (true) return factor1Type;}
                }
                else
                {
                        {if (true) return factor1Type;}
                }
    throw new Error("Missing return statement in function");
  }

  static final public String op_MAS_MENOS() throws ParseException {
        Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tMAS:
      token = jj_consume_token(tMAS);
                           {if (true) return "+";}
      break;
    case tMENOS:
      token = jj_consume_token(tMENOS);
                             {if (true) return "-";}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Symbol.Types tipo() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tINT:
      jj_consume_token(tINT);
                {if (true) return Symbol.Types.INT;}
      break;
    case tCHAR:
      jj_consume_token(tCHAR);
                {if (true) return Symbol.Types.CHAR;}
      break;
    case tBOOL:
      jj_consume_token(tBOOL);
                {if (true) return Symbol.Types.BOOL;}
      break;
    case tVOID:
      jj_consume_token(tVOID);
                {if (true) return Symbol.Types.VOID;}
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Symbol.Types termino(Boolean sendRef) throws ParseException {
        Symbol.Types factor1Type, factor2Type = null;
        String token = null;
    factor1Type = factor(sendRef);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case tPROD:
      case tDIV:
      case tMOD:
        ;
        break;
      default:
        jj_la1[33] = jj_gen;
        break label_11;
      }
      token = op_MULT();
      factor2Type = factor(sendRef);
                        if (factor1Type != factor2Type)
                        {
                                ErrorSemantico.deteccion("En termino, los operandos deben ser del mismo tipo");
                                haHabidoError = true;
                        }

                        if (token == "*")
                                code.addInst(OpCode.TMS);
                        else if (token == "/")
                                code.addInst(OpCode.DIV);
                        else
                                code.addInst(OpCode.MOD);
    }
                if (factor2Type != null)
                {
                        {if (true) return factor1Type;}
                }
                else
                {
                        {if (true) return factor1Type;}
                }
    throw new Error("Missing return statement in function");
  }

  static final public String op_MULT() throws ParseException {
        Token token;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tPROD:
      token = jj_consume_token(tPROD);
                            {if (true) return "*";}
      break;
    case tDIV:
      token = jj_consume_token(tDIV);
                           {if (true) return "/";}
      break;
    case tMOD:
      token = jj_consume_token(tMOD);
                          {if (true) return "%";}
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Symbol.Types factor(Boolean sendRef) throws ParseException {
        Symbol.Types factorType;
        String token = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tAP:
    case tFALSE:
    case tTRUE:
    case tINT2CHAR:
    case tCHAR2INT:
    case tCONST_STRING:
    case tCONST_INT:
    case tCONST_CHAR:
    case tID:
      factorType = primario(sendRef);
      break;
    case tMENOS:
    case tNOT:
      token = operador_not();
      factorType = primario(sendRef);
                        if (token == "!")
                                code.addInst(OpCode.NGB);
                        else
                                code.addInst(OpCode.NGI);
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                {if (true) return factorType;}
    throw new Error("Missing return statement in function");
  }

  static final public Symbol.Types primario(Boolean sendRef) throws ParseException {
        Token token = null, tokenConst = null;
        Symbol.Types symbolType = null, symbolCastToChar = null, symbolCastToInt = null;
        Symbol arr = null;
        Symbol simbolo = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case tAP:
      jj_consume_token(tAP);
      symbolType = expresion(false);
      jj_consume_token(tCP);
      break;
    case tINT2CHAR:
      jj_consume_token(tINT2CHAR);
      jj_consume_token(tAP);
      symbolType = expresion(false);
      jj_consume_token(tCP);
                        if (sendRef)
                        {
                                ErrorSemantico.deteccion("No puede pasarse un valor calculado como referencia");
                                haHabidoError = true;
                        }

                        if (symbolType == Symbol.Types.INT)
                                symbolType = Symbol.Types.CHAR;
                        else
                        {
                                ErrorSemantico.deteccion("El tipo de la expresi\u00f3n al hacer cast to char debe ser int");
                                haHabidoError = true;
                        }
      break;
    case tCHAR2INT:
      jj_consume_token(tCHAR2INT);
      jj_consume_token(tAP);
      symbolType = expresion(false);
      jj_consume_token(tCP);
                        if (sendRef)
                        {
                                ErrorSemantico.deteccion("No puede pasarse un valor calculado como referencia");
                                haHabidoError = true;
                        }

                        if (symbolType == Symbol.Types.CHAR)
                                symbolType = Symbol.Types.INT;
                        else
                        {
                                ErrorSemantico.deteccion("El tipo de la expresi\u00f3n al hacer cast to int debe ser char");
                                haHabidoError = true;
                        }
      break;
    default:
      jj_la1[36] = jj_gen;
      if (jj_2_6(2)) {
        symbolType = inst_invoc_proc();
      } else if (jj_2_7(2)) {
        token = jj_consume_token(tID);
        jj_consume_token(tACOR);
        symbolType = expresion(sendRef);
        jj_consume_token(tCCOR);
                        if (symbolType != Symbol.Types.INT)
                        {
                                ErrorSemantico.deteccion("El \u00edndice del array debe ser de tipo int");
                                haHabidoError = true;
                        }
                        else
                        {
                                try {
                                        arr = tablaSimbolos.getSymbol(token.image);
                                }
                                catch(SymbolNotFoundException e)
                                {
                                        ErrorSemantico.deteccion("El simbolo "+token.image+" no existe, l\u00ednea "+token.beginLine);
                                }

                                if (arr.type != Symbol.Types.ARRAY)
                                {
                                        ErrorSemantico.deteccion("El identificador " + arr.name + " no es un array, es de tipo " + arr.type);
                                        haHabidoError = true;
                                }
                                else
                                {
                                        SymbolArray array = (SymbolArray)arr;
                                        symbolType = array.baseType;

                                        // Cálculo de dirección del indexado, base+index
                                        int nivelRelativo = tablaSimbolos.level - array.nivel;
                                        code.addInst(OpCode.SRF, nivelRelativo, (int)array.dir);

                                        if (arr.parClass == Symbol.ParameterClass.REF)
                                                code.addInst(OpCode.DRF);

                                        code.addInst(OpCode.PLUS);

                                        if (!sendRef)
                                                code.addInst(OpCode.DRF);       // Carga el valor del elemento en la pila
                                }
                        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case tID:
          token = jj_consume_token(tID);
                        try {
                                simbolo = tablaSimbolos.getSymbol(token.image);
                        }
                        catch(SymbolNotFoundException e)
                        {
                                ErrorSemantico.deteccion("El simbolo "+token.image+" no existe, l\u00ednea "+token.beginLine);
                        }

                        symbolType = simbolo.type;

                        int nivelRelativo =  tablaSimbolos.level - simbolo.nivel;
                        if (simbolo.parClass == Symbol.ParameterClass.REF)
                        {
                                if (symbolType == Symbol.Types.ARRAY)
                                {
                                        SymbolArray array = (SymbolArray)simbolo;
                                        int arrLen = array.maxInd - array.minInd + 1;

                                        if (!sendRef) // Se debe pasar el vector por valor
                                        {
                                                for (int i = 0; i < arrLen; i++)
                                                {
                                                        code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
                                                        code.addInst(OpCode.DRF);       // Carga la direccion de la variable
                                                        code.addInst(OpCode.STC, i);    // Desplazamiento en el array
                                                        code.addInst(OpCode.PLUS);
                                                        code.addInst(OpCode.DRF); // Cargar el valor de la direccion anteriormente cargada
                                                }
                                        }
                                        else
                                        {
                                                code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
                                                code.addInst(OpCode.DRF);       // Carga la direccion de la variable
                                        }
                                }
                                else
                                {
                                        code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
                                        code.addInst(OpCode.DRF);       // Carga el valor del puntero
                                        if (!sendRef)
                                                code.addInst(OpCode.DRF);       // Carga el valor de la variable en la pila
                                }
                        }
                        else
                        {
                                if (symbolType == Symbol.Types.ARRAY)
                                {
                                        SymbolArray array = (SymbolArray)simbolo;
                                        int arrLen = array.maxInd - array.minInd + 1;

                                        if (!sendRef)
                                        {
                                                for (int i = 0; i < arrLen; i++)
                                                {
                                                        code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir + i);
                                                        code.addInst(OpCode.DRF);       // Carga el valor de la variable en la pila
                                                }
                                        }
                                        else
                                        {
                                                code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
                                        }
                                }
                                else
                                {
                                        code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
                                        if (!sendRef)
                                                code.addInst(OpCode.DRF);       // Carga el valor de la variable en la pila
                                }
                        }
          break;
        case tCONST_INT:
          tokenConst = jj_consume_token(tCONST_INT);
                        symbolType = Symbol.Types.INT;
                        code.addInst(OpCode.STC, Integer.valueOf(tokenConst.image));
          break;
        case tCONST_CHAR:
          tokenConst = jj_consume_token(tCONST_CHAR);
                        symbolType = Symbol.Types.CHAR;

                        char[] character = tokenConst.image.toCharArray();

                        code.addInst(OpCode.STC, Integer.valueOf(character[1]));
          break;
        case tCONST_STRING:
          tokenConst = jj_consume_token(tCONST_STRING);
                        symbolType = Symbol.Types.STRING;

                        // Convierte la cadena a charArray
                        char[] chars = tokenConst.image.toCharArray();

                        for (int i = 1; i < chars.length-1; i++)
                        {
                                code.addInst(OpCode.STC, (int)chars[i]);
                                code.addInst(OpCode.WRT, 0);
                        }
          break;
        case tTRUE:
          tokenConst = jj_consume_token(tTRUE);
                        symbolType = Symbol.Types.BOOL;
                        code.addInst(OpCode.STC, 1);
          break;
        case tFALSE:
          tokenConst = jj_consume_token(tFALSE);
                        symbolType = Symbol.Types.BOOL;
                        code.addInst(OpCode.STC, 0);
          break;
        default:
          jj_la1[37] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
                {if (true) return symbolType;}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_3R_24() {
    if (jj_scan_token(tACOR)) return true;
    return false;
  }

  static private boolean jj_3R_12() {
    if (jj_3R_16()) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  static private boolean jj_3R_14() {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tAP)) return true;
    return false;
  }

  static private boolean jj_3R_21() {
    if (jj_scan_token(tVOID)) return true;
    return false;
  }

  static private boolean jj_3_7() {
    if (jj_scan_token(tID)) return true;
    if (jj_scan_token(tACOR)) return true;
    return false;
  }

  static private boolean jj_3R_20() {
    if (jj_scan_token(tBOOL)) return true;
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_13()) return true;
    return false;
  }

  static private boolean jj_3R_22() {
    if (jj_scan_token(tID)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_24()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_15() {
    if (jj_scan_token(tELSE)) return true;
    if (jj_scan_token(tIF)) return true;
    return false;
  }

  static private boolean jj_3R_19() {
    if (jj_scan_token(tCHAR)) return true;
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_12()) return true;
    if (jj_scan_token(tPC)) return true;
    return false;
  }

  static private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_18()) {
    jj_scanpos = xsp;
    if (jj_3R_19()) {
    jj_scanpos = xsp;
    if (jj_3R_20()) {
    jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_18() {
    if (jj_scan_token(tINT)) return true;
    return false;
  }

  static private boolean jj_3R_17() {
    if (jj_3R_22()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_23()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_3R_15()) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_14()) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_15()) return true;
    return false;
  }

  static private boolean jj_3R_13() {
    if (jj_3R_16()) return true;
    if (jj_scan_token(tID)) return true;
    return false;
  }

  static private boolean jj_3R_23() {
    if (jj_scan_token(tCOMMA)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public clikeTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  /** Whether we are looking ahead. */
  static private boolean jj_lookingAhead = false;
  static private boolean jj_semLA;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[38];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x202000,0x0,0x202000,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x202000,0x200000,0x80000000,0x80000000,0x7e000000,0x7e000000,0x300000,0x300000,0x0,0x1c00000,0x1c00000,0x202000,0x2000,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x4e0,0x4e0,0x100000,0x0,0x4e0,0x4e0,0x100000,0x0,0x7800,0x80800c,0x100000,0xee0302,0x100000,0xee0302,0x100000,0x100000,0x0,0x10,0x10,0x10,0x10,0x80f80c,0x4e0,0x80f80c,0xee0302,0x2,0x1,0x1,0x0,0x0,0x0,0x0,0x4e0,0x0,0x0,0xee0302,0x60000,0xe80300,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[7];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public clike(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public clike(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new clikeTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public clike(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new clikeTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public clike(clikeTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(clikeTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 38; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.add(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[58];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 38; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 58; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 7; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
