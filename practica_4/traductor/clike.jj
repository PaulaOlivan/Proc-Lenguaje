//*****************************************************************
// File:   clike.jj
// Author: Procesadores de Lenguajes-University of Zaragoza
// Date:   noviembre 2022
// Coms:   compilar mediante "ant"
//*****************************************************************



options {
 	IGNORE_CASE = false;
 	COMMON_TOKEN_ACTION = false;
	
 	// DEBUG_PARSER = true;
 	// ERROR_REPORTING = false;
}

PARSER_BEGIN(clike)

package traductor;
import java.io.*;
import lib.symbolTable.*;
import java.util.*;
import lib.symbolTable.exceptions.*;
import lib.errores.ErrorSemantico;
import lib.tools.codeGeneration.*;
import lib.tools.codeGeneration.PCodeInstruction.OpCode;

public class clike {

	protected static SymbolTable tablaSimbolos = new SymbolTable();
	protected static CodeBlock code = new CodeBlock();
	protected static boolean encontradoReturn = false;
	protected static boolean returnEnWhile = false;
	protected static boolean haHabidoError = false;
	protected static String outputName;
	
	public static void main(String[] args) {
		clike parser = null;
		
		try {
			if(args.length == 0) {
				parser = new clike(System.in);
			}
			else {
				parser = new clike(new java.io.FileInputStream(args[0]));
			}

			if (args.length < 2) {
				System.err.println("Error: Debe indicar el nombre del fichero de salida");
				System.exit(1);
			}

			outputName = args[1]; 	// Nombre del fichero de salida
			
			//Programa es el símbolo inicial de la gramática
			parser.Programa();
			//...
			//System.out.println("***** Análisis terminado con éxito *****");
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
			System.err.println("LEX_ERROR: " + e);
			haHabidoError = true;
		}
		catch (ParseException e) {
			System.err.println("PARSE_ERROR: " + e);
			haHabidoError = true;
		}
		catch (Exception e) {
			System.err.println("ERROR: " + e);
			haHabidoError = true;

		}
	}

	
	public static void print_argument(Symbol.Types type){
		
		if (type == Symbol.Types.INT 
			|| 
			type == Symbol.Types.BOOL
			)
		{
			code.addInst(OpCode.WRT, 1);
		}
		else if (type == Symbol.Types.CHAR)
		{
			code.addInst(OpCode.WRT, 0);
		}
		else if (type == Symbol.Types.STRING)
		{
			// Los strings se imprimen conforme se reciben
		}
	}
}
PARSER_END(clike)

SKIP : // Carácteres que debe detectar pero no generar token
{
	" "
|	"\t"
|	"\n"
|	"\r" 
}

TOKEN : {
 	< #mLETTER: ["a"-"z"] >
|	< #MLETTER: ["A"-"Z"] >
|	< #LETTER:	(<mLETTER> | <MLETTER>) >
|	< #DIGIT: 	["0"-"9"] >
|	< #NUMBER:	(<DIGIT>)+ >
|	< #IDCHAR:	(<LETTER> | <DIGIT> | "_") >
}

TOKEN : {
	< tIBLOQUE:	"{"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("inicio de bloque " + "\"" + matchedToken + "\"");
						}
|	< tFBLOQUE:	"}"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("fin de bloque " + "\"" + matchedToken + "\"");
						}
|	< tAP:	"("> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("inicio de parentesis" + "\"" + matchedToken + "\"");
						}
|	< tCP:	")"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("cierre de parentesis " + "\"" + matchedToken + "\"");
						}
|	< tACOR:	"["> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("inicio de cochete " + "\"" + matchedToken + "\"");
						}
|	< tCCOR:	"]"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("cierre de corchete " + "\"" + matchedToken + "\"");
						}
|	< tREFER:	"&"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador de referencia " + "\"" + matchedToken + "\"");
						}
|	< tPC:		";"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("caracter de fin de linea " + "\"" + matchedToken + "\"");
						}
|	< tASSIGN:	"="> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador asignacion " + "\"" + matchedToken + "\"");
						}
|	< tMAS:		"+"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador suma " + "\"" + matchedToken + "\"");
						}
|	< tMENOS:	"-"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador resta " + "\"" + matchedToken + "\"");
						}
|	< tPROD:	"*"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador multiplicacion " + "\"" + matchedToken + "\"");
						}
|	< tDIV:		"/"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador division " + "\"" + matchedToken + "\"");
						}
|	< tMOD:		"%"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador modulo " + "\"" + matchedToken + "\"");
						}
|	< tMEN:		"<"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador menor que " + "\"" + matchedToken + "\"");
						}
|	< tMAY:		">"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador mayor que " + "\"" + matchedToken + "\"");
						}
|	< tMENI:	"<="> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador menor o igual " + "\"" + matchedToken + "\"");
						}
|	< tMAYI:	">="> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador mayor o igual " + "\"" + matchedToken + "\"");
						}
|	< tDIF:		"!="> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador distinto " + "\"" + matchedToken + "\"");
						}
|	< tIG:		"=="> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador igual " + "\"" + matchedToken + "\"");
						}
|	< tOR:		"||"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador or exclusivo " + "\"" + matchedToken + "\"");
						}
|	< tAND:		"&&"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador and exclusivo " + "\"" + matchedToken + "\"");
						}
|	< tNOT:		"!"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador negar " + "\"" + matchedToken + "\"");
						}
|	< tWHILE:	"while"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("token " + "\"" + matchedToken + "\"");
						}
|	< tIF:	"if"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("token " + "\"" + matchedToken + "\"");
						}
|	< tELSE: "else"> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("token " + "\"" + matchedToken + "\"");
						}
}

TOKEN : {
	< tBOOL: 	"bool" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("token " + "\"" + matchedToken + "\"");
						}
|	< tCHAR: 	"char" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("token " + "\"" + matchedToken + "\"");
						}
|	< tINT:		"int" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("token " + "\"" + matchedToken + "\"");
						}
| 	< tFALSE:	"false" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("false " + "\"" + matchedToken + "\"");
						}
|	< tTRUE:	"true" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("true " + "\"" + matchedToken + "\"");
						}
|	< tVOID: 	"void" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("procedimiento " + "\"" + matchedToken + "\"");
						}
|	< tPRINT: 	"print" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("función" + "\"" + matchedToken + "\"");
						}
|	< tPRINTLN: "print_ln" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("función " + "\"" + matchedToken + "\"");
						}
|	< tREAD: 	"read" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("función " + "\"" + matchedToken + "\"");
						}
|	< tREADLN: 	"read_ln" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("función " + "\"" + matchedToken + "\"");
						}
|	< tRETURN: 	"return" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("token " + "\"" + matchedToken + "\"");
						}
|	< tMAIN: 	"main"	> {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("palabra reservada inicio de función principal " + "\"" + matchedToken + "\"");
						}
|	< tINT2CHAR: 	"int2char" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("función " + "\"" + matchedToken + "\"");
						}
|	< tCHAR2INT: 	"char2int" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("función " + "\"" + matchedToken + "\"");
						}
|	< tCONST_STRING:	"\"" ((~["\"" , "\n"]) | "\"\"")* "\"" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("constante string " + "\"" + matchedToken + "\"");
						}
|	< tCOMMA:	"," > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("operador concatenación " + "\"" + matchedToken + "\"");
						}
|	< tCONST_INT:	(<NUMBER>) > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("constante entera " + "\"" + matchedToken + "\"");
						}
|	< tCONST_CHAR:		"\'" ((~["\"" , "\n"]) | "\"\"") "\'" > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("constante char " + "\"" + matchedToken + "\"");
						}
|	< tID:		(<IDCHAR>)+ > {
							//System.out.print("(" + matchedToken.beginLine + "," + matchedToken.beginColumn +"):");
							//System.out.println("identificador " + "\"" + matchedToken + "\"");
						}

}

SPECIAL_TOKEN : {
	<tBASURA : ~[] >
	{
		System.err.println("ERROR LEXICO: ("+ matchedToken.beginLine + "," + matchedToken.beginColumn + ") :simbolo no reconocido: " + matchedToken);
		matchedToken.image = " ";
		//haHabidoError = true;
	}
|	< tCOMM: 	"//"(~["\n"])*> {} //Unicamente lo reconocemos pero no lo sacamos por pantalla

}

//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void Programa() : 
{
	code.addInst(OpCode.ENP, "MAIN");
	
	Symbol temp_bin = new SymbolInt("compiler_temporal_int");
	try {
		tablaSimbolos.insertSymbol(temp_bin);
	}
	catch (AlreadyDefinedSymbolException e) {
		System.err.println("ERROR INTERNO, el identificador compiler_temporal_int ya está declarado");
		haHabidoError = true;
	}
}
{
	( declaracion() )*
	< EOF >
	{
		code.addInst(OpCode.LVP);

		// Escribimos el código en un fichero
		if (!haHabidoError)
		{	
			System.out.println("Compilación finalizada. Se ha generado el fichero " + outputName + ".pcode");
			code.writeCodeToFile(outputName+".pcode");
		}
		else
			System.err.println("No se ha generado el código por haber errores en el programa");
	}
}

void declaracion() :
{
	List<Symbol> simbolos;
}
{
	LOOKAHEAD(3) // Afecta solo a la orden que le sigue, en este caso declaracion_variables que mira que coincidan los 3 primeros tokens
	declaracion_variables() <tPC>
|	LOOKAHEAD(2)
	declaracion_func_proc()
| 	declaracion_main()
}

void declaracion_variables() :
{
	Symbol.Types type;
	List<Symbol> symbols;
}
{
	type = tipo()
	symbols = ids(type)
	{
		try {
			for (Symbol simbolo : symbols)
				tablaSimbolos.insertSymbol(simbolo);
		}
		catch (AlreadyDefinedSymbolException e){
			System.out.println(e);
		}
	}
}

ArrayList<Symbol> ids(Symbol.Types type) :
{
	ArrayList<Symbol> symbols = null;
	Symbol symbol;
}
{
	symbol = decl_1_variable(type) (< tCOMMA > symbols = ids(type))?
	{
		if (symbols == null)
			symbols = new ArrayList<Symbol>();

		symbols.add(symbol);
		return symbols;
	}
}

Symbol decl_1_variable(Symbol.Types type) :
{
	Token id;
	Token size = null;
}
{
	id = <tID> (< tACOR > size = < tCONST_INT > < tCCOR >)?
	{
		if (size != null)
		{
			return new SymbolArray(id.image, 0, Integer.parseInt(size.image)-1, type);
		}
		else
			return Symbol.createNormalSymbol(id.image, type);
	}
}

void declaracion_main() :
{
	Symbol.Types tipo;
	Token token;
	ArrayList<Symbol> parametros = null;
	Symbol simbolo;	
}
{
	tipo = tipo()
	token = < tMAIN >
	< tAP >
	(parametros = declaracion_parametros())?
	< tCP >
	{
		if (parametros == null)
		{
			parametros = new ArrayList<Symbol>();
		}
	
		if (tipo == Symbol.Types.VOID)
		{
			simbolo = new SymbolProcedure(token.image, parametros);
		}
		else
		{
			simbolo = new SymbolFunction(token.image, parametros, tipo);
		}
	
		try{
			tablaSimbolos.insertSymbol(simbolo);
		}
		catch (AlreadyDefinedSymbolException e){
			System.out.println(e);
		}

		for (Symbol simb : parametros)
		{
			try{
				tablaSimbolos.insertSymbol(simb);
			}
			catch (AlreadyDefinedSymbolException e) {
				System.out.println(e+", simbolo "+simb);
			}
		}

		code.addLabel("MAIN");
	}
	bloque_codigo_con_variables()
	{
		tablaSimbolos.removeBlock();
	}
}


void declaracion_func_proc() :
{
	Symbol.Types tipo;
	Token token;
	ArrayList<Symbol> parametros = null;
	Symbol simbolo;
}
{
(
	tipo = tipo()
	token = < tID >
	{
		if (tipo == Symbol.Types.VOID)
		{
			simbolo = new SymbolProcedure(token.image);
		}
		else
		{
			simbolo = new SymbolFunction(token.image, tipo);
			encontradoReturn = false;
		}

		try{
			tablaSimbolos.insertSymbol(simbolo);
		}
		catch (AlreadyDefinedSymbolException e){
			System.out.println(e);
		}

		tablaSimbolos.insertBlock(token.image);
		code.addLabel(token.image.toUpperCase());
	}
	< tAP >
	(parametros = declaracion_parametros())?
	< tCP >
	{		
		if (parametros == null)
		{
			parametros = new ArrayList<Symbol>();
		}
		
		Symbol funcSimb = tablaSimbolos.getSymbol(token.image);
		if (funcSimb instanceof SymbolFunction)
		{
			SymbolFunction func = (SymbolFunction) funcSimb;
			func.setParameters(parametros);
		}
		else if (funcSimb instanceof SymbolProcedure)
		{
			System.out.println("Procedimiento "+funcSimb.name+", parámetros: "+parametros);
			SymbolProcedure func = (SymbolProcedure) funcSimb;
			func.setParameters(parametros);
		}
	}
	bloque_codigo_con_variables()
	{
		tablaSimbolos.removeBlock();

		if (tipo != Symbol.Types.VOID && !encontradoReturn)
		{
			if (returnEnWhile)
			{
				ErrorSemantico.deteccion("Error, los returns en un while no garantizan que la función " + simbolo.name + " termine con return");
				haHabidoError = true;
			}
			else
			{
				ErrorSemantico.deteccion("Error, la función " + simbolo.name + " puede no terminar con return");
				haHabidoError = true;
			}
		}

		if (tipo == Symbol.Types.VOID)
		{
			code.addInst(OpCode.CSF);
		}
	}
)
}

ArrayList<Symbol> declaracion_parametros() :
{
	Symbol symbol;
	ArrayList<Symbol> parametros = new ArrayList<Symbol>();
}
{
	symbol = declaracion_parametro() (< tCOMMA > parametros = declaracion_parametros())?
	{
		parametros.add(0, symbol);

		try{
			tablaSimbolos.insertSymbol(symbol);
		}
		catch (AlreadyDefinedSymbolException e) {
			System.out.println(e+", simbolo "+symbol);
		}

		if (symbol.type == Symbol.Types.ARRAY && symbol.parClass == Symbol.ParameterClass.VAL) //Si es un array, nos apilan la dirección del array (el primer elemento)
		{
			SymbolArray array = (SymbolArray) symbol;
			int arraySize = array.maxInd-array.minInd+1;
			int nivelRelativo = tablaSimbolos.level - symbol.nivel; //Para saber el desplazamiento restamos el level donde apuntamos menos el nivel al que queremos ir
			
			for (int i = 0; i < arraySize; i++)
			{
				code.addInst(OpCode.SRF, nivelRelativo, (int)array.dir+i);		// Nos apilan el valor de la variable
				code.addInst(OpCode.ASGI);
			}
		}
		else
		{
			int nivelRelativo = tablaSimbolos.level - symbol.nivel; //Para saber el desplazamiento restamos el level donde apuntamos menos el nivel al que queremos ir
			code.addInst(OpCode.SRF, nivelRelativo, (int)symbol.dir);			// Nos apilan el valor de la variable
			code.addInst(OpCode.ASGI);
		}
		
		return parametros;
	}
}

Symbol declaracion_parametro() :
{
	Symbol.Types type;
	Symbol symbol;
	Token ref = null;	
}
{
	type = tipo() (ref = < tREFER >)? symbol = decl_1_variable(type)
	{
		if (ref != null)
		{
			symbol.parClass = Symbol.ParameterClass.REF;	
			return symbol;
		}
		else
		{
			symbol.parClass = Symbol.ParameterClass.VAL;
			return symbol;
		}
	}
}

void instruccion() :
{}
{
	inst_leer() < tPC >
|	inst_leer_linea() < tPC > 
|	inst_escribir() < tPC > 
|	inst_escribir_linea() < tPC >
// Para evitar ambigüedad con invocación de función
| 	LOOKAHEAD(2) inst_invoc_proc() < tPC > 	
|	inst_asignacion() < tPC > 
|	inst_seleccion()
|	inst_iteracion()
|	inst_return() < tPC > 
}

void inst_leer() :
{
	Symbol simb;
	Symbol.Types symbolType = null;
}
{
	< tREAD >
	< tAP >
	symbolType = expresion(true)
	{
		if (symbolType == Symbol.Types.INT || symbolType == Symbol.Types.BOOL)
			code.addInst(OpCode.RD, 1); 
		else if (symbolType == Symbol.Types.CHAR)
			code.addInst(OpCode.RD, 0);
		else
		{
			ErrorSemantico.deteccion("En read(), la variable no es de tipo entero, char o Boolean", null);
			haHabidoError = true;
		}
	}
	( 
		< tCOMMA > symbolType = expresion(true)
		{
			if (symbolType == Symbol.Types.INT || symbolType == Symbol.Types.BOOL)
				code.addInst(OpCode.RD, 1); 
			else if (symbolType == Symbol.Types.CHAR)
				code.addInst(OpCode.RD, 0);
			else
			{
				ErrorSemantico.deteccion("En read(), la variable no es de tipo entero, char o Boolean", null);
				haHabidoError = true;
			}
		}
	)*
	< tCP >
}

void inst_leer_linea() :
{
	Token token;
	Symbol simb = null;
	Symbol.Types symbolType = null;
}
{
	< tREADLN >
	< tAP >
	( 
	symbolType = expresion(true)
	{
		if (symbolType == Symbol.Types.INT || symbolType == Symbol.Types.BOOL)
			code.addInst(OpCode.RD, 1); 
		else if (symbolType == Symbol.Types.CHAR)
			code.addInst(OpCode.RD, 0);
		else
		{
			ErrorSemantico.deteccion("En read(), la variable no es de tipo entero, char o Boolean", null);
			haHabidoError = true;
		}
	}
	)?
	( 
		< tCOMMA > symbolType = expresion(true)
		{
			if (symbolType == Symbol.Types.INT || symbolType == Symbol.Types.BOOL)
				code.addInst(OpCode.RD, 1); 
			else if (symbolType == Symbol.Types.CHAR)
				code.addInst(OpCode.RD, 0);
			else
			{
				ErrorSemantico.deteccion("En read(), la variable no es de tipo entero, char o Boolean", null);
				haHabidoError = true;
			}
		}	
	)*
	< tCP >
	{
		Symbol simb_bin = tablaSimbolos.getSymbol("compiler_temporal_int");
		String label = CGUtils.newLabel();
		code.addLabel("READLNLOOP" + label);

		int nivelRelativo = tablaSimbolos.level - simb_bin.nivel;
		code.addInst(OpCode.SRF, nivelRelativo, (int)simb_bin.dir);
		code.addInst(OpCode.RD, 0);

		code.addInst(OpCode.SRF, nivelRelativo, (int)simb_bin.dir);
		code.addInst(OpCode.DRF);

		code.addInst(OpCode.STC, '\n');
		code.addInst(OpCode.NEQ);
		code.addInst(OpCode.JMT, "READLNLOOP" + label);
		// Añadimos bucle hasta detectar salto de línea
	}
}

void inst_escribir() :
{
	ArrayList<Symbol.Types> types;
}
{
	< tPRINT >
	< tAP >
	argumentos_escribir()
	< tCP >
}

void inst_escribir_linea() :
{
}
{
	(
	< tPRINTLN >
	< tAP >
	(argumentos_escribir())?
	< tCP >
	)
	{
		code.addInst(OpCode.STC, '\n');
		code.addInst(OpCode.WRT, 0);
	}
}

void argumentos_escribir() :
{
	Symbol.Types type;
}
{
	type = expresion(false) { print_argument(type); } (< tCOMMA > type = expresion(false) { print_argument(type);})*
	{}
}

ArrayList<Symbol.Types> argumentos(ArrayList<Symbol> arguments, String name, Integer line) :
{
	Symbol.Types type;
	ArrayList<Symbol.Types> types = new ArrayList<Symbol.Types>();
	ArrayList<Symbol> arguments_internal = new ArrayList<Symbol>(arguments);
}
{
	type = expresion(arguments_internal.get(0).parClass == Symbol.ParameterClass.REF) 
	{ 
		types.add(type); 		
		
		if (arguments_internal.size() > 0)
			arguments_internal.remove(0);
		else
		{
			ErrorSemantico.deteccion("Hay más argumentos de la cuenta en la llamada a función "+name+", linea: "+line);
			haHabidoError = true;
		}
	} 
	(
		< tCOMMA > type = expresion(arguments_internal.get(0).parClass == Symbol.ParameterClass.REF) 
		{ 
			types.add(type); 
			
			if (arguments_internal.size() > 0)
				arguments_internal.remove(0);
			else
			{
				ErrorSemantico.deteccion("Hay más argumentos de la cuenta en la llamada a función "+name+", linea: "+line);
				haHabidoError = true;
			}
		}
	)*
	{
		if (arguments_internal.size() > 0)
		{
			ErrorSemantico.deteccion("Hay menos argumentos de la cuenta en la llamada a función "+name+", linea: "+line);
			haHabidoError = true;
		}
		return types;
	}
}

void inst_asignacion() :
{
	Symbol.Types symbolAss, symbolExp;
}
{
	symbolAss = asignable()
	< tASSIGN >
	symbolExp = expresion(false)
	{
		if (symbolAss != symbolExp)
		{
			ErrorSemantico.deteccion("En asignación, la expresión de tipo " + symbolExp + " no coincide con el tipo de la variable: "+symbolAss, token);
			haHabidoError = true;
		}

		code.addInst(OpCode.ASG);
	}
}

Symbol.Types asignable() :
{
	Symbol.Types index = null;
	Token token;
}
{
	token = < tID > ( < tACOR > index = expresion(false) < tCCOR > )?
	{
		if (index == null)
		{
			try {
				Symbol simbolo = tablaSimbolos.getSymbol(token.image);

				int nivelRelativo =  tablaSimbolos.level - simbolo.nivel;
				code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);	// Dirección de la variable

				if (simbolo.parClass == Symbol.ParameterClass.REF)
					code.addInst(OpCode.DRF);
				
				return simbolo.type;
			}

			catch(SymbolNotFoundException e)
			{
				ErrorSemantico.deteccion("El símbolo " + token.image + " no existe, línea " + token.beginLine);
				haHabidoError = true;
			}

			return null;
		}
		else // Nuestro simbolo forma parte de un vector
		{
			if (index != Symbol.Types.INT)
			{
				ErrorSemantico.deteccion("En asignación, el índice del vector " + token.image + " no es de tipo entero", token);
				haHabidoError = true;
			}

			SymbolArray array = (SymbolArray) tablaSimbolos.getSymbol(token.image);

			// Cálculo de dirección del indexado, base+index

			int nivelRelativo = tablaSimbolos.level - array.nivel;
			code.addInst(OpCode.SRF, nivelRelativo, (int)array.dir);
			
			if (array.parClass == Symbol.ParameterClass.REF)
				code.addInst(OpCode.DRF);

			code.addInst(OpCode.PLUS);

			return array.baseType;
		}
	}
}

void inst_seleccion() :
{
	String label;
	String labelEnd = "ENDCONDITIONAL" + CGUtils.newLabel();
	Boolean oldReturn = encontradoReturn;	// Para controlar si hay un return dentro del if
	Boolean buscarReturn = !encontradoReturn;
	Boolean encontradoReturn_en_if = false;
	Boolean encontradoReturn_en_if_else = false;
	Boolean encontradoReturn_en_else = false;
}
{
	< tIF > < tAP > expresion(false) < tCP >
	{
		label = "ENDIF" + CGUtils.newLabel();
		code.addInst(OpCode.JMF, label);
	} 
	bloque_codigo()
	{ 
		code.addInst(OpCode.JMP, labelEnd);
		code.addLabel(label); 

		if (buscarReturn && encontradoReturn) // Si ha aparecido un return
		{
			encontradoReturn_en_if = true;
			encontradoReturn = false;
		}
		else		// Si no se ha encontrado un return 
		{
			encontradoReturn_en_if = false;
		}
	}
	(
		LOOKAHEAD(2)
		encontradoReturn_en_if_else = bloque_else_ifs(labelEnd, buscarReturn, true)
		| 
		< tELSE > 
		{
			label = "ENDELSE" + CGUtils.newLabel();
		} 
		bloque_codigo() 
		{ 
			code.addLabel(label);
			code.addLabel(labelEnd);

			if (buscarReturn && encontradoReturn) // Si ha aparecido un return
			{
				encontradoReturn_en_else = true;
				encontradoReturn = false;
			}
			else		// Si no se ha encontrado un return 
			{
				encontradoReturn_en_else = false;
			}
		}
	)?
	{
		encontradoReturn = !buscarReturn || (encontradoReturn_en_if && (encontradoReturn_en_else || encontradoReturn_en_if_else));
	}
}

Boolean bloque_else_ifs(String labelEnd, Boolean buscarReturn, Boolean buscarElse):
{
	String label;

	Boolean oldReturn = encontradoReturn;	// Para controlar si hay un return dentro del if
	Boolean encontradoReturn_en_if = false;
	Boolean encontradoReturn_en_else = false;
}
{
	< tELSE > < tIF > < tAP > expresion(false) < tCP > 
	{
		label = "ENDELSEIF" + CGUtils.newLabel();
		code.addInst(OpCode.JMF, label);
	}
	bloque_codigo() 
	{
		code.addInst(OpCode.JMP, labelEnd); 
		code.addLabel(label); 
		
		if (buscarReturn && encontradoReturn) // Si ha aparecido un return
		{
			encontradoReturn_en_if = true;
			encontradoReturn = false;
		}
		else		// Si no se ha encontrado un return 
		{
			encontradoReturn_en_if = false;
		}
	}
	(
		LOOKAHEAD(2)
		bloque_else_ifs(labelEnd, buscarReturn, false)
		| < tELSE > 
		{
			label = "ENDELSE" + CGUtils.newLabel();
		} 
		bloque_codigo() 
		{ 
			if (buscarReturn && encontradoReturn) // Si ha aparecido un return
			{
				encontradoReturn_en_else = true;
				encontradoReturn = false;
			}
			else		// Si no se ha encontrado un return 
			{
				encontradoReturn_en_else = false;
			}

			code.addLabel(label);
			code.addLabel(labelEnd);
		}
	)?
	{
		if (!buscarElse)
			encontradoReturn_en_else = true;

		return !buscarReturn || (encontradoReturn_en_else && encontradoReturn_en_if);
	}
}

void inst_iteracion() :
{
	String labelInit = "INITWHILE" + CGUtils.newLabel();
	String labelEnd = "ENDWHILE" + CGUtils.newLabel();
	code.addLabel(labelInit);
	Boolean habiaReturn = encontradoReturn;
}
{
	< tWHILE > < tAP > expresion(false) 
	{
		code.addInst(OpCode.JMF, labelEnd);
	} 
	< tCP > bloque_codigo()
	{
		code.addInst(OpCode.JMP, labelInit);
		code.addLabel(labelEnd);

		encontradoReturn = habiaReturn;	// Dentro de un while, los returns pueden no suceder
		returnEnWhile = true;
	}
}

void bloque_codigo() :
{}
{
	< tIBLOQUE >
	(instruccion())*
	< tFBLOQUE >
}

void bloque_codigo_con_variables() :
{}
{
	< tIBLOQUE >
	(declaracion_variables() < tPC >)*
	(instruccion())*
	< tFBLOQUE >
}


Symbol.Types inst_return() :
{
	Symbol.Types type;
}
{
	< tRETURN > type = expresion(false) 
	{
		String funcName = tablaSimbolos.getBlockName();
		Symbol symb = tablaSimbolos.getSymbol(funcName);
		SymbolFunction simbolFunc = null;

		if (symb == null)
		{
			ErrorSemantico.deteccion("El bloque actual no es una función o procedimiento", token);
			haHabidoError = true;
		}
		else {
			if (symb instanceof SymbolFunction)
				simbolFunc = (SymbolFunction) symb;
			else
			{
				ErrorSemantico.deteccion("El bloque actual no admite returns", token);
				haHabidoError = true;
			}
		}


		if (simbolFunc != null && type != simbolFunc.returnType)
		{
			ErrorSemantico.deteccion("En return, el tipo de la expresión no coincide con el tipo de retorno de la función", token);
			haHabidoError = true;
		}
		
		encontradoReturn = true;

		code.addInst(OpCode.CSF);
		return type;
	}
}

Symbol.Types inst_invoc_proc() :
{
	Token token;
	Symbol.Types tipo = null;
	Boolean error = false; 
	ArrayList<Symbol> parameters = new ArrayList<Symbol>();
	String name = "";
}
{
	token = < tID >
	{
		try{
			Symbol SimboloDeFuncion = tablaSimbolos.getSymbol(token.image);
	
			if (SimboloDeFuncion.type == Symbol.Types.PROCEDURE)
			{
				SymbolProcedure procedimiento = (SymbolProcedure) SimboloDeFuncion;
				tipo = Symbol.Types.VOID;

				parameters = procedimiento.parList;
				name = procedimiento.name;
			}
			else if (SimboloDeFuncion.type == Symbol.Types.FUNCTION)
			{
				SymbolFunction funcion = (SymbolFunction) SimboloDeFuncion;
				tipo = funcion.returnType;

				parameters = funcion.parList;
				name = funcion.name;				
			}
			else
			{
				ErrorSemantico.deteccion("El identificador " + token.image + " no es una función ni un procedimiento", token);
				haHabidoError = true;
			}
		}
		catch (SymbolNotFoundException e) {
			error = true;
			System.out.println(e+", linea "+token.beginLine+", columna "+token.beginColumn);
			haHabidoError = true;
		}
	}
	< tAP >
	(argumentos(parameters, name, token.beginLine))?
	< tCP >
	{	
		if (!error){
			code.addOSFInst(tablaSimbolos.getTopDir(), tablaSimbolos.level, name.toUpperCase());
			return tipo;
		}
	}
}

String operador_not() :
{
	Token token;
}
{
	(token = < tNOT > {return "!";} | token = < tMENOS > { return "-";})
}

Symbol.Types expresion(Boolean sendRef) :
{
	Symbol.Types factor1Type, factor2Type = null;
	String token = null;
	String label = "ENDANDOR" + CGUtils.newLabel();
}
{
	factor1Type = relacion(sendRef)
 	(	
		token = and_or()
		{
			if (token == "||")
			{
				code.addInst(OpCode.DUP);
				code.addInst(OpCode.JMT, label);
			}
			else
			{
				code.addInst(OpCode.DUP);
				code.addInst(OpCode.JMF, label);
			}
		} 
		factor2Type = relacion(sendRef)
		{
			if (factor1Type != Symbol.Types.BOOL || factor2Type!= Symbol.Types.BOOL)
			{
				ErrorSemantico.deteccion("En operación lógica, los operandos deben ser de tipo Boolean ("+
										factor1Type+", "+factor2Type+")");
				haHabidoError = true;
			}
		}
	)*
	{
		if (factor2Type != null)
		{
			code.addLabel(label);
			return Symbol.Types.BOOL;			
		}
		else
		{
			return factor1Type;
		}
	}
}

String and_or() :
{
	Token token;
}
{
	(
	token = < tOR > { return "||";}
|	token = < tAND > { return "&&";}
	)
}

Symbol.Types relacion(Boolean sendRef) :
{
	Symbol.Types factor1Type, factor2Type = null;
	String token = null;
}
{
	factor1Type = expresion_simple(sendRef)
	( 
		token = operador_relacional()
		factor2Type = expresion_simple(sendRef)
		{
			if (factor1Type != factor2Type)
			{
				ErrorSemantico.deteccion("En relacion,los operandos deben ser del mismo tipo ("+
										factor1Type+", "+factor2Type+")");
				haHabidoError = true;
			}
			
			if (token == "==")
				code.addInst(OpCode.EQ);
			else if (token == "<")
				code.addInst(OpCode.LT);
			else if (token == ">")
				code.addInst(OpCode.GT);
			else if (token == "<=")
				code.addInst(OpCode.LTE);
			else if (token == ">=")
				code.addInst(OpCode.GTE);
			else if (token == "!=")
				code.addInst(OpCode.NEQ);
		}
	)?
	{
		if (factor2Type != null)
		{
			return Symbol.Types.BOOL;
		}
		else
		{
			return factor1Type;
		}
	}
}

String operador_relacional() :
{
	Token token;
}
{
(
	token = < tIG > { return "==";}
|	token = < tMEN > { return "<";}
|	token = < tMAY > { return ">";}
|	token = < tMENI > { return "<=";}
|	token = < tMAYI > { return ">=";}
|	token = < tDIF > { return "!=";}
)
}

Symbol.Types expresion_simple(Boolean sendRef) :
{
	Symbol.Types factor1Type, factor2Type = null;
	String token = null;
}
{
	factor1Type = termino(sendRef)
	( 
		token = op_MAS_MENOS() 
		factor2Type = termino(sendRef)
		{
			if (factor1Type != factor2Type)
			{
				ErrorSemantico.deteccion("En expresión simple, los operandos deben ser del mismo tipo");
				haHabidoError = true;
			}

			if (token == "+")
				code.addInst(OpCode.PLUS);
			else
				code.addInst(OpCode.SBT);
		}
	)*
	{
		if (factor2Type != null)
		{
			return factor1Type;
		}
		else
		{
			return factor1Type;
		}
	}
}

String op_MAS_MENOS() :
{
	Token token;
}
{
(
	token = < tMAS > { return "+";}
|	token = < tMENOS > { return "-";}
)
}

Symbol.Types tipo() :
{}
{
	< tINT >
	{
		return Symbol.Types.INT;
	}
|	< tCHAR >
	{
		return Symbol.Types.CHAR;
	}
|	< tBOOL >
	{
		return Symbol.Types.BOOL;
	}
|	< tVOID >
	{
		return Symbol.Types.VOID;
	}
}

Symbol.Types termino(Boolean sendRef) :
{
	Symbol.Types factor1Type, factor2Type = null;
	String token = null;
}
{
	factor1Type = factor(sendRef)
	( 
		token = op_MULT()
		factor2Type = factor(sendRef)
		{
			if (factor1Type != factor2Type)
			{
				ErrorSemantico.deteccion("En termino, los operandos deben ser del mismo tipo");
				haHabidoError = true;
			}

			if (token == "*")
				code.addInst(OpCode.TMS);
			else if (token == "/")
				code.addInst(OpCode.DIV);
			else
				code.addInst(OpCode.MOD);
		}
	)*
	{
		if (factor2Type != null)
		{
			return factor1Type;
		}
		else
		{
			return factor1Type;
		}
	}
}

String op_MULT() :
{
	Token token;
}
{
(
	token = < tPROD > { return "*";}
|	token = < tDIV > { return "/";}
|	token = < tMOD> { return "%";}
)
}


Symbol.Types factor(Boolean sendRef) :
{
	Symbol.Types factorType;
	String token = null;
}
{
	(
		factorType = primario(sendRef)
		|	token = operador_not()
		factorType = primario(sendRef)
		{
			if (token == "!")
				code.addInst(OpCode.NGB);
			else
				code.addInst(OpCode.NGI);
		}
	)
	{
		return factorType;
	}
}


Symbol.Types primario(Boolean sendRef) :
{
	Token token = null, tokenConst = null;
	Symbol.Types symbolType = null, symbolCastToChar = null, symbolCastToInt = null;
}
{
	(	
			< tAP > symbolType = expresion(false) < tCP >
		|	< tINT2CHAR > < tAP > symbolType = expresion(false) < tCP >
		{
			if (sendRef)
			{
				ErrorSemantico.deteccion("No puede pasarse un valor calculado como referencia");
				haHabidoError = true;
			}
			
			if (symbolType == Symbol.Types.INT)
				symbolType = Symbol.Types.CHAR;
			else
			{
				ErrorSemantico.deteccion("El tipo de la expresión al hacer cast to char debe ser int");
				haHabidoError = true;
			}
		}
		|	< tCHAR2INT > < tAP > symbolType = expresion(false) < tCP >
		{
			if (sendRef)
			{
				ErrorSemantico.deteccion("No puede pasarse un valor calculado como referencia");
				haHabidoError = true;
			}
				
			if (symbolType == Symbol.Types.CHAR)
				symbolType = Symbol.Types.INT;
			else
			{
				ErrorSemantico.deteccion("El tipo de la expresión al hacer cast to int debe ser char");
				haHabidoError = true;
			}
		}
		|	LOOKAHEAD(2) symbolType = inst_invoc_proc()
		|	LOOKAHEAD(2) token = < tID > < tACOR > symbolType = expresion(sendRef) < tCCOR >
		{
			if (symbolType != Symbol.Types.INT)
			{
				ErrorSemantico.deteccion("El índice del array debe ser de tipo int");
				haHabidoError = true;
			}
			else
			{
				Symbol arr = tablaSimbolos.getSymbol(token.image);

				if (arr.type != Symbol.Types.ARRAY)
				{
					ErrorSemantico.deteccion("El identificador " + arr.name + " no es un array, es de tipo " + arr.type);
					haHabidoError = true;
				}
				else
				{					
					SymbolArray array = (SymbolArray)arr;
					symbolType = array.baseType;

					// Cálculo de dirección del indexado, base+index
					int nivelRelativo = tablaSimbolos.level - array.nivel;
					code.addInst(OpCode.SRF, nivelRelativo, (int)array.dir);

					if (arr.parClass == Symbol.ParameterClass.REF)
						code.addInst(OpCode.DRF);

					code.addInst(OpCode.PLUS);
					
					if (!sendRef)
						code.addInst(OpCode.DRF);	// Carga el valor del elemento en la pila
				}
			}
		}
		|	token = < tID >
		{ 
			Symbol simbolo = tablaSimbolos.getSymbol(token.image);
			symbolType = simbolo.type;
			
			int nivelRelativo =  tablaSimbolos.level - simbolo.nivel;
			if (simbolo.parClass == Symbol.ParameterClass.REF)
			{
				if (symbolType == Symbol.Types.ARRAY)
				{
					SymbolArray array = (SymbolArray)simbolo;
					int arrLen = array.maxInd - array.minInd + 1;
					
					if (!sendRef) // Se debe pasar el vector por valor
					{
						for (int i = 0; i < arrLen; i++)
						{
							code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
							code.addInst(OpCode.DRF);	// Carga la direccion de la variable
							code.addInst(OpCode.STC, i);	// Desplazamiento en el array
							code.addInst(OpCode.PLUS);	
							code.addInst(OpCode.DRF); // Cargar el valor de la direccion anteriormente cargada
						}
					}
					else
					{
						code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
						code.addInst(OpCode.DRF);	// Carga la direccion de la variable
					}
				}
				else
				{
					code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
					code.addInst(OpCode.DRF);	// Carga el valor del puntero
					if (!sendRef) 
						code.addInst(OpCode.DRF);	// Carga el valor de la variable en la pila
				}
			}
			else 
			{
				if (symbolType == Symbol.Types.ARRAY)
				{
					SymbolArray array = (SymbolArray)simbolo;
					int arrLen = array.maxInd - array.minInd + 1;
					
					if (!sendRef)
					{
						for (int i = 0; i < arrLen; i++)
						{
							code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir + i);
							code.addInst(OpCode.DRF);	// Carga el valor de la variable en la pila
						}
					}
					else 
					{
						code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
					}
				}
				else
				{
					code.addInst(OpCode.SRF, nivelRelativo, (int)simbolo.dir);
					if (!sendRef)
						code.addInst(OpCode.DRF);	// Carga el valor de la variable en la pila
				}
			}
		}
		|	tokenConst = < tCONST_INT > 
		{ 
			symbolType = Symbol.Types.INT; 
			code.addInst(OpCode.STC, Integer.valueOf(tokenConst.image));
		}
		|	tokenConst = < tCONST_CHAR > 
		{ 
			symbolType = Symbol.Types.CHAR; 

			char[] character = tokenConst.image.toCharArray();

			code.addInst(OpCode.STC, Integer.valueOf(character[1]));
		}
		|	tokenConst = < tCONST_STRING > 
		{ 
			symbolType = Symbol.Types.STRING; 

			// Convierte la cadena a charArray
			char[] chars = tokenConst.image.toCharArray();

			for (int i = 1; i < chars.length-1; i++)
			{
				code.addInst(OpCode.STC, (int)chars[i]);
				code.addInst(OpCode.WRT, 0);
			}
		}
		|	tokenConst = < tTRUE >
		{ 
			symbolType = Symbol.Types.BOOL; 
			code.addInst(OpCode.STC, 1);
		}
		|	tokenConst = < tFALSE >
		{ 
			symbolType = Symbol.Types.BOOL; 
			code.addInst(OpCode.STC, 0);
		}
	)
	{
		return symbolType;
	}
}